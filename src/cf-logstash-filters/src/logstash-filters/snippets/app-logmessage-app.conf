##------------------------------
## Parses LogMessage APP events.
##------------------------------
if [@source][type] =~ /APP(|\/.*)$/ {
    mutate {
        add_tag => [ "logmessage-app" ]
    }
    mutate {
        # Firehose sets values like "APP/PROC/WEB". Rename just to "APP" for simplicity.
        replace => { "[@source][type]" => "APP" }
    }

    # Parse application logs based on msg format.
    # Marks unknown format with [unknown_msg_format] tag.

    ## ---- Format 1: JSON
    if [@message] =~ /^\s*{".*}\s*$/ { # if it looks like JSON
        truncate {
            fields => ["@message"]
            add_tag => [ "_messagetrimmed" ]
            length_bytes => 32765
        }
        if !("_messagetrimmed" in [tags]) {
            json {
                source => "@message"
                target => "app"
                id => "cloudfoundry/app-message/json"
                tag_on_failure => "json_parsing_failed"
            }
            if !("json_parsing_failed" in [tags]) {
                if [app][message] {
                    mutate {
                        rename => { "[app][message]" => "@message" }
                    }
                } else if [app][msg] {
                    mutate {
                        rename => { "[app][msg]" => "@message" }
                    }
                }

                # concat message and exception
                if [app][exception] {
                    mutate {
                        ## NOTE: keep line break and new line spacing (new line is inserted in logstash in such a way)
                        replace => { "@message" => "%{@message}\n%{[app][exception]}" }
                        remove_field => [ "[app][exception]" ]
                    }
                }
                mutate {
                    rename => { "[app][level]" => "@level" } # @level
                }
                mutate {
                    # Top-level fields to http.request
                    rename => { "[app][bytes_read]" => "[http][request][bytes_read]" }
                    rename => { "[app][user_id]" => "[http][request][user_id]" }
                    rename => { "[app][duration]" => "[http][request][duration]" }
                    rename => { "[app][size]" => "[http][request][size]" }
                    rename => { "[app][status]" => "[http][request][status]" }
                    rename => { "[app][duration]" => "[http][request][duration]" }
                    rename => { "[app][referer]" => "[http][request][referer]" }
                    rename => { "[app][remoteHost]" => "[http][request][remote_ip]" }
                    rename => { "[app][request][client_ip]" => "[http][request][client_ip]" }
                    rename => { "[app][request][host]" => "[http][request][host]" }
                    rename => { "[app][request][method]" => "[http][request][method]" }
                    rename => { "[app][request][proto]" => "[http][request][protocol]" }
                    rename => { "[app][request][remote_ip]" => "[http][request][remote_ip]" }
                    rename => { "[app][request][remote_port]" => "[http][request][remote_port]" }
                    rename => { "[app][request][status]" => "[http][request][status]" }
                    rename => { "[app][request][uri]" => "[http][request][uri]" }
                    rename => { "[app][requestedHost]" => "[http][request][host]" }
                    rename => { "[app][requestedUrl]" => "[http][request][url]" }
                    rename => { "[app][requestMethod]" => "[http][request][method]" }
                    rename => { "[app][requestTime]" => "[http][request][duration]" }
                    rename => { "[app][requestUri]" => "[http][request][uri]" }
                    rename => { "[app][serverProtocol]" => "[http][request][protocol]" }
                    rename => { "[app][size]" => "[http][request][size]" }
                    rename => { "[app][time_iso8601]" => "[http][request][timestamp]" }
                    rename => { "[app][ts]" => "[http][request][timestamp]" }
                    rename => { "[app][user_id]" => "[http][request][user_id]" }
                    rename => { "[app][userAgent]" => "[http][request][user_agent]" }

                    # Request object fields to http.request
                    rename => { "[app][request][remote_ip]" => "[http][request][remote_ip]" }
                    rename => { "[app][request][remote_port]" => "[http][request][remote_port]" }
                    rename => { "[app][request][client_ip]" => "[http][request][client_ip]" }
                    rename => { "[app][request][proto]" => "[http][request][proto]" }
                    rename => { "[app][request][method]" => "[http][request][method]" }
                    rename => { "[app][request][host]" => "[http][request][host]" }
                    rename => { "[app][request][uri]" => "[http][request][uri]" }
                    rename => { "[app][request][headers]" => "[http][request][headers]" }

                    # Response headers to http.response
                    rename => { "[app][resp_headers]" => "[http][response][headers]" }
                }
            } else {
                mutate {
                    add_tag => [ "unknown_msg_format" ]
                    remove_tag => ["json_parsing_failed"]
                }
            }
        }
    }
    ## ---- Format 2: "[CONTAINER] .." (Tomcat logs)
    else if [@message] =~ /^\s*\[CONTAINER\]/ {
        # Tomcat specific parsing (in accordance with https://github.com/cloudfoundry/java-buildpack-support/blob/master/tomcat-logging-support/src/main/java/com/gopivotal/cloudfoundry/tomcat/logging/CloudFoundryFormatter.java)
        grok {
            match => [ "@message", "(?<app_logger>\[CONTAINER\]%{SPACE}%{NOTSPACE})%{SPACE}%{LOGLEVEL:@level}%{SPACE}%{GREEDYDATA:@message}" ]
            overwrite => [ "@message", "@level" ]
            tag_on_failure => [ "unknown_msg_format" ]
            id => "cloudfoundry/app-message/tomcat_message/grok"
        }
        mutate {
            rename => { "app_logger" => "[app][logger]" }
        }
    } else {
            mutate {
                add_tag => [ "unknown_msg_format" ]
            }
    }
}