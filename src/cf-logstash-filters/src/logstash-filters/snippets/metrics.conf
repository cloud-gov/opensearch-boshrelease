
# # gunzip
# ruby {
#     code => "
#     require 'zlib'
#     require 'stringio'
#     begin
#         gz = Zlib::GzipReader.new(StringIO.new(event.get('message').to_s.b))
#         decompressed = gz.read
#         gz.close
#         event.set('message', decompressed)
#     rescue => e
#         event.tag('gzip_failed')
#         event.set('gzip_error', e.message)
#     end
#     "
# }

# base64 decode
# ruby {
#     code => "
#     require 'base64'
#     begin
#         decoded = Base64.decode64(event.get('message'))
#         event.set('message',decoded)
#     rescue => e
#         event.tag('base64_decode_failed')
#         event.set('decoded_error', e.message)
#     end
#     "
# }

ruby {
  code => 'event.set("test", "ruby_works")'
}
ruby {
    code => '
      begin
        message = event.get("message")

        # Get more bytes to understand the pattern
        first_10_bytes = []
        (0..9).each do |i|
          if i < message.length
            first_10_bytes << message[i].ord
          end
        end
        event.set("first_10_bytes", first_10_bytes)

        # Try to see if this might be deflate instead of gzip
        # Bytes 78,45 could be deflate header

        require "zlib"

        # Try raw deflate (not gzip)
        inflater = Zlib::Inflate.new(-Zlib::MAX_WBITS)
        decompressed = inflater.inflate(message)
        inflater.close

        event.set("deflate_success", true)
        event.set("deflate_length", decompressed.length)
        event.set("deflate_preview", decompressed[0, 100])

      rescue => e
        event.set("deflate_error", e.message)

        # If deflate fails, try regular gzip anyway
        begin
          require "zlib"
          gzip_decompressed = Zlib::Inflate.inflate(message)
          event.set("gzip_success", true)
          event.set("gzip_preview", gzip_decompressed[0, 100])
        rescue => ge
          event.set("gzip_error", ge.message)
        end
      end
    '
  }


json
{
    source => "message"
    tag_on_failure => ["_jsonparsefailure"]
}

date
{
match => ["Time", "ISO8601"]
target => "@timestamp"
}
mutate
{
add_field => {"@type" => "metrics"}
rename => {"[Tags][Organization GUID]"=>"[@cf][org_id]"}
rename => {"[Tags][Organization name]"=>"[@cf][org]"}
rename => {"[Tags][Space GUID]"=>"[@cf][space_id]"}
rename => {"[Tags][Space name]"=>"[@cf][space]"}
rename => {"[Tags][Service plan name]"=>"[@cf][service_plan]"}
rename => {"[Tags][Plan GUID]"=>"[@cf][plan_id]"}
rename => {"[Tags][Service GUID]"=>"[@cf][service_instance_id]"}
rename => {"[Tags][service]"=>"[@cf][service]"}
rename => {"[Tags][Service offering name]"=>"[@cf][service_offering]"}
rename => {"[Tags][Instance GUID]"=>"[@cf][instance_id]"}
rename => {"[Tags][Instance name]"=>"[@cf][instance]"}

rename => {"[Tags][Created at]" => "[created at]"}
rename => {"[Tags][broker]"=>"[broker]"}
rename => {"[Tags][environment]"=>"environment"}
rename => {"[Tags][DomainName]"=>"[metric][domain_name]"}
rename => {"[InstanceName]"=>"[metric][instance_id]"}
rename => {"[MetricName]"=>"[metric][name]"}
rename => {"[Average]"=>"[metric][average]"}
rename => {"[Unit]"=>"[metric][unit]"}
remove_field => ["[Tags][client]"]
}