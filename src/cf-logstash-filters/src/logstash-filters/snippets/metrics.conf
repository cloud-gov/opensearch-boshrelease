
# # gunzip
# ruby {
#     code => "
#     require 'zlib'
#     require 'stringio'
#     begin
#         gz = Zlib::GzipReader.new(StringIO.new(event.get('message').to_s.b))
#         decompressed = gz.read
#         gz.close
#         event.set('message', decompressed)
#     rescue => e
#         event.tag('gzip_failed')
#         event.set('gzip_error', e.message)
#     end
#     "
# }

# base64 decode
# ruby {
#     code => "
#     require 'base64'
#     begin
#         decoded = Base64.decode64(event.get('message'))
#         event.set('message',decoded)
#     rescue => e
#         event.tag('base64_decode_failed')
#         event.set('decoded_error', e.message)
#     end
#     "
# }

ruby {
  code => 'event.set("test", "ruby_works")'
}

ruby {
    code => '
      require "zlib"
      require "base64"
      require "json"

      begin
        message = event.get("message")

        # Force binary encoding to handle gzipped data properly
        binary_message = message.force_encoding("ASCII-8BIT")

        # Try base64 decode first, then gzip (your original Lambda path)
        base64_decoded = Base64.decode64(binary_message)
        decompressed_data = Zlib::Inflate.inflate(base64_decoded)

        # Now we have a string with concatenated JSON objects like: {}{}{}
        # We need to parse each JSON object individually

        json_objects = []
        current_pos = 0
        brace_count = 0
        start_pos = 0

        # Parse character by character to find complete JSON objects
        decompressed_data.each_char.with_index do |char, i|
          case char
          when "{"
            if brace_count == 0
              start_pos = i
            end
            brace_count += 1
          when "}"
            brace_count -= 1
            if brace_count == 0
              # Found a complete JSON object
              json_str = decompressed_data[start_pos..i]
              begin
                parsed_json = JSON.parse(json_str)
                json_objects << parsed_json
              rescue JSON::ParserError => e
                event.set("json_parse_error", "Error parsing JSON object #{json_objects.length + 1}: #{e.message}")
                event.tag("_jsonparsefailure")
              end
            end
          end
        end

        # Create a new event for each JSON object
        json_objects.each_with_index do |json_obj, index|
          new_event = LogStash::Event.new(json_obj)
          new_event.set("[@metadata][original_s3_key]", event.get("[@metadata][s3][key]"))
          new_event.set("[@metadata][json_object_number]", index + 1)
          new_event.set("[@metadata][total_json_objects]", json_objects.length)

          yield new_event
        end

        # Cancel the original event since we created new ones
        event.cancel

      rescue Base64::InvalidBase64CharacterError => e
        event.set("base64_error", e.message)
        event.tag("_base64error")
      rescue Zlib::Error => e
        event.set("gzip_error", e.message)
        event.tag("_gziperror")
      rescue => e
        event.set("processing_error", e.message)
        event.set("error_class", e.class.to_s)
        event.tag("_processingerror")
      end
    '
  }


json
{
    source => "message"
    tag_on_failure => ["_jsonparsefailure"]
}

date
{
match => ["Time", "ISO8601"]
target => "@timestamp"
}
mutate
{
add_field => {"@type" => "metrics"}
rename => {"[Tags][Organization GUID]"=>"[@cf][org_id]"}
rename => {"[Tags][Organization name]"=>"[@cf][org]"}
rename => {"[Tags][Space GUID]"=>"[@cf][space_id]"}
rename => {"[Tags][Space name]"=>"[@cf][space]"}
rename => {"[Tags][Service plan name]"=>"[@cf][service_plan]"}
rename => {"[Tags][Plan GUID]"=>"[@cf][plan_id]"}
rename => {"[Tags][Service GUID]"=>"[@cf][service_instance_id]"}
rename => {"[Tags][service]"=>"[@cf][service]"}
rename => {"[Tags][Service offering name]"=>"[@cf][service_offering]"}
rename => {"[Tags][Instance GUID]"=>"[@cf][instance_id]"}
rename => {"[Tags][Instance name]"=>"[@cf][instance]"}

rename => {"[Tags][Created at]" => "[created at]"}
rename => {"[Tags][broker]"=>"[broker]"}
rename => {"[Tags][environment]"=>"environment"}
rename => {"[Tags][DomainName]"=>"[metric][domain_name]"}
rename => {"[InstanceName]"=>"[metric][instance_id]"}
rename => {"[MetricName]"=>"[metric][name]"}
rename => {"[Average]"=>"[metric][average]"}
rename => {"[Unit]"=>"[metric][unit]"}
remove_field => ["[Tags][client]"]
}