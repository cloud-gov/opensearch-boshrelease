
# # gunzip
# ruby {
#     code => "
#     require 'zlib'
#     require 'stringio'
#     begin
#         gz = Zlib::GzipReader.new(StringIO.new(event.get('message').to_s.b))
#         decompressed = gz.read
#         gz.close
#         event.set('message', decompressed)
#     rescue => e
#         event.tag('gzip_failed')
#         event.set('gzip_error', e.message)
#     end
#     "
# }

# base64 decode
# ruby {
#     code => "
#     require 'base64'
#     begin
#         decoded = Base64.decode64(event.get('message'))
#         event.set('message',decoded)
#     rescue => e
#         event.tag('base64_decode_failed')
#         event.set('decoded_error', e.message)
#     end
#     "
# }

  ruby {
    code => '
      require "zlib"
      require "base64"
      require "json"

      message = event.get("message")
      results = {}

      # Test 1: Raw message analysis
      results["raw_length"] = message.length
      results["raw_class"] = message.class.to_s
      results["raw_encoding"] = message.encoding.to_s
      results["raw_first_10_bytes"] = message[0..9].bytes if message.length >= 10
      results["raw_first_20_chars"] = message[0..19].inspect if message.length >= 20

      # Test 2: Try different string encodings on raw message
      encodings_to_try = ["UTF-8", "ASCII-8BIT", "ISO-8859-1", "US-ASCII", "UTF-16", "UTF-32"]

      encodings_to_try.each do |enc|
        begin
          encoded = message.force_encoding(enc)
          results["encoding_#{enc.downcase.gsub("-", "_")}_success"] = true
          results["encoding_#{enc.downcase.gsub("-", "_")}_valid"] = encoded.valid_encoding?
        rescue => e
          results["encoding_#{enc.downcase.gsub("-", "_")}_error"] = e.message
        end
      end

      # Test 3: Try base64 decode
      begin
        base64_decoded = Base64.decode64(message)
        results["base64_decode_success"] = true
        results["base64_decoded_length"] = base64_decoded.length
        results["base64_decoded_encoding"] = base64_decoded.encoding.to_s
        results["base64_decoded_first_10_bytes"] = base64_decoded[0..9].bytes if base64_decoded.length >= 10

        # Check if base64 decoded looks like gzip
        if base64_decoded.length >= 2
          first_two = base64_decoded[0..1].bytes
          results["base64_decoded_is_gzip_magic"] = (first_two == [31, 139])
        end
      rescue => e
        results["base64_decode_error"] = e.message
        base64_decoded = nil
      end

      # Test 4: Try URL decode
      begin
        require "uri"
        url_decoded = URI.decode_www_form_component(message)
        results["url_decode_success"] = true
        results["url_decoded_length"] = url_decoded.length
        results["url_decoded_different"] = (url_decoded != message)
      rescue => e
        results["url_decode_error"] = e.message
      end

      # Test 5: Try gzip decompress on raw message
      begin
        gzip_raw = Zlib::Inflate.inflate(message)
        results["gzip_raw_success"] = true
        results["gzip_raw_length"] = gzip_raw.length
        results["gzip_raw_preview"] = gzip_raw[0..100].inspect
      rescue => e
        results["gzip_raw_error"] = e.message
      end

      # Test 6: Try gzip decompress on base64 decoded (if successful)
      if base64_decoded
        begin
          gzip_base64 = Zlib::Inflate.inflate(base64_decoded)
          results["gzip_base64_success"] = true
          results["gzip_base64_length"] = gzip_base64.length
          results["gzip_base64_preview"] = gzip_base64[0..200].inspect

          # Try to parse as JSON
          begin
            json_test = JSON.parse(gzip_base64.split("\n")[0])
            results["gzip_base64_json_success"] = true
            results["gzip_base64_json_keys"] = json_test.keys if json_test.is_a?(Hash)
          rescue => je
            results["gzip_base64_json_error"] = je.message
          end

        rescue => e
          results["gzip_base64_error"] = e.message
        end
      end

      # Test 7: Try different encodings on base64 decoded before gzip
      if base64_decoded
        encodings_to_try.each do |enc|
          begin
            reencoded = base64_decoded.force_encoding(enc)
            if reencoded.valid_encoding?
              gzip_reencoded = Zlib::Inflate.inflate(reencoded)
              results["gzip_#{enc.downcase.gsub("-", "_")}_success"] = true
              results["gzip_#{enc.downcase.gsub("-", "_")}_length"] = gzip_reencoded.length
              results["gzip_#{enc.downcase.gsub("-", "_")}_preview"] = gzip_reencoded[0..50].inspect
            end
          rescue => e
            results["gzip_#{enc.downcase.gsub("-", "_")}_error"] = e.message
          end
        end
      end

      # Test 8: Try hex decode
      begin
        if message.length.even? && message.match?(/^[0-9a-fA-F]+$/)
          hex_decoded = [message].pack("H*")
          results["hex_decode_success"] = true
          results["hex_decoded_length"] = hex_decoded.length

          # Try gzip on hex decoded
          begin
            gzip_hex = Zlib::Inflate.inflate(hex_decoded)
            results["gzip_hex_success"] = true
            results["gzip_hex_preview"] = gzip_hex[0..100].inspect
          rescue => e
            results["gzip_hex_error"] = e.message
          end
        else
          results["hex_decode_not_hex"] = true
        end
      rescue => e
        results["hex_decode_error"] = e.message
      end

      # Test 9: Check if raw message is already JSON
      begin
        json_raw = JSON.parse(message)
        results["raw_json_success"] = true
        results["raw_json_type"] = json_raw.class.to_s
      rescue => e
        results["raw_json_error"] = e.message
      end

      # Test 10: Check if raw message contains newline-delimited JSON
      lines = message.split("\n")
      if lines.length > 1
        results["raw_has_multiple_lines"] = true
        results["raw_line_count"] = lines.length

        begin
          first_line_json = JSON.parse(lines[0])
          results["raw_first_line_json_success"] = true
        rescue => e
          results["raw_first_line_json_error"] = e.message
        end
      end

      # Set all results as fields
      results.each do |key, value|
        event.set("test_#{key}", value)
      end
    '
  }


json
{
    source => "message"
    tag_on_failure => ["_jsonparsefailure"]
}

date
{
match => ["Time", "ISO8601"]
target => "@timestamp"
}
mutate
{
add_field => {"@type" => "metrics"}
rename => {"[Tags][Organization GUID]"=>"[@cf][org_id]"}
rename => {"[Tags][Organization name]"=>"[@cf][org]"}
rename => {"[Tags][Space GUID]"=>"[@cf][space_id]"}
rename => {"[Tags][Space name]"=>"[@cf][space]"}
rename => {"[Tags][Service plan name]"=>"[@cf][service_plan]"}
rename => {"[Tags][Plan GUID]"=>"[@cf][plan_id]"}
rename => {"[Tags][Service GUID]"=>"[@cf][service_instance_id]"}
rename => {"[Tags][service]"=>"[@cf][service]"}
rename => {"[Tags][Service offering name]"=>"[@cf][service_offering]"}
rename => {"[Tags][Instance GUID]"=>"[@cf][instance_id]"}
rename => {"[Tags][Instance name]"=>"[@cf][instance]"}

rename => {"[Tags][Created at]" => "[created at]"}
rename => {"[Tags][broker]"=>"[broker]"}
rename => {"[Tags][environment]"=>"environment"}
rename => {"[Tags][DomainName]"=>"[metric][domain_name]"}
rename => {"[InstanceName]"=>"[metric][instance_id]"}
rename => {"[MetricName]"=>"[metric][name]"}
rename => {"[Average]"=>"[metric][average]"}
rename => {"[Unit]"=>"[metric][unit]"}
remove_field => ["[Tags][client]"]
}